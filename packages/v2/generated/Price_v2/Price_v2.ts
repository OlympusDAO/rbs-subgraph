// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  Address,
  BigInt,
  Bytes,
  Entity,
  ethereum,
  JSONValue,
  TypedMap,
} from "@graphprotocol/graph-ts";

export class AssetAdded extends ethereum.Event {
  get params(): AssetAdded__Params {
    return new AssetAdded__Params(this);
  }
}

export class AssetAdded__Params {
  _event: AssetAdded;

  constructor(event: AssetAdded) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AssetMovingAverageUpdated extends ethereum.Event {
  get params(): AssetMovingAverageUpdated__Params {
    return new AssetMovingAverageUpdated__Params(this);
  }
}

export class AssetMovingAverageUpdated__Params {
  _event: AssetMovingAverageUpdated;

  constructor(event: AssetMovingAverageUpdated) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AssetPriceFeedsUpdated extends ethereum.Event {
  get params(): AssetPriceFeedsUpdated__Params {
    return new AssetPriceFeedsUpdated__Params(this);
  }
}

export class AssetPriceFeedsUpdated__Params {
  _event: AssetPriceFeedsUpdated;

  constructor(event: AssetPriceFeedsUpdated) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AssetPriceStrategyUpdated extends ethereum.Event {
  get params(): AssetPriceStrategyUpdated__Params {
    return new AssetPriceStrategyUpdated__Params(this);
  }
}

export class AssetPriceStrategyUpdated__Params {
  _event: AssetPriceStrategyUpdated;

  constructor(event: AssetPriceStrategyUpdated) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AssetRemoved extends ethereum.Event {
  get params(): AssetRemoved__Params {
    return new AssetRemoved__Params(this);
  }
}

export class AssetRemoved__Params {
  _event: AssetRemoved;

  constructor(event: AssetRemoved) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class PriceStored extends ethereum.Event {
  get params(): PriceStored__Params {
    return new PriceStored__Params(this);
  }
}

export class PriceStored__Params {
  _event: PriceStored;

  constructor(event: PriceStored) {
    this._event = event;
  }

  get asset_(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get price_(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get timestamp_(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Price_v2__VERSIONResult {
  value0: i32;
  value1: i32;

  constructor(value0: i32, value1: i32) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set(
      "value0",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value0)),
    );
    map.set(
      "value1",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value1)),
    );
    return map;
  }

  getMajor(): i32 {
    return this.value0;
  }

  getMinor(): i32 {
    return this.value1;
  }
}

export class Price_v2__getAssetDataResultValue0Struct extends ethereum.Tuple {
  get approved(): boolean {
    return this[0].toBoolean();
  }

  get storeMovingAverage(): boolean {
    return this[1].toBoolean();
  }

  get useMovingAverage(): boolean {
    return this[2].toBoolean();
  }

  get movingAverageDuration(): BigInt {
    return this[3].toBigInt();
  }

  get nextObsIndex(): i32 {
    return this[4].toI32();
  }

  get numObservations(): i32 {
    return this[5].toI32();
  }

  get lastObservationTime(): BigInt {
    return this[6].toBigInt();
  }

  get cumulativeObs(): BigInt {
    return this[7].toBigInt();
  }

  get obs(): Array<BigInt> {
    return this[8].toBigIntArray();
  }

  get strategy(): Bytes {
    return this[9].toBytes();
  }

  get feeds(): Bytes {
    return this[10].toBytes();
  }
}

export class Price_v2__getPriceResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  get_price(): BigInt {
    return this.value0;
  }

  get_timestamp(): BigInt {
    return this.value1;
  }
}

export class Price_v2__getPriceIn2Result {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  get_price(): BigInt {
    return this.value0;
  }

  get_timestamp(): BigInt {
    return this.value1;
  }
}

export class Price_v2 extends ethereum.SmartContract {
  static bind(address: Address): Price_v2 {
    return new Price_v2("Price_v2", address);
  }

  KEYCODE(): Bytes {
    const result = super.call("KEYCODE", "KEYCODE():(bytes5)", []);

    return result[0].toBytes();
  }

  try_KEYCODE(): ethereum.CallResult<Bytes> {
    const result = super.tryCall("KEYCODE", "KEYCODE():(bytes5)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  VERSION(): Price_v2__VERSIONResult {
    const result = super.call("VERSION", "VERSION():(uint8,uint8)", []);

    return new Price_v2__VERSIONResult(result[0].toI32(), result[1].toI32());
  }

  try_VERSION(): ethereum.CallResult<Price_v2__VERSIONResult> {
    const result = super.tryCall("VERSION", "VERSION():(uint8,uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Price_v2__VERSIONResult(value[0].toI32(), value[1].toI32()),
    );
  }

  assets(param0: BigInt): Address {
    const result = super.call("assets", "assets(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);

    return result[0].toAddress();
  }

  try_assets(param0: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall("assets", "assets(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  decimals(): i32 {
    const result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    const result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  execOnSubmodule(subKeycode_: Bytes, callData_: Bytes): Bytes {
    const result = super.call(
      "execOnSubmodule",
      "execOnSubmodule(bytes20,bytes):(bytes)",
      [
        ethereum.Value.fromFixedBytes(subKeycode_),
        ethereum.Value.fromBytes(callData_),
      ],
    );

    return result[0].toBytes();
  }

  try_execOnSubmodule(
    subKeycode_: Bytes,
    callData_: Bytes,
  ): ethereum.CallResult<Bytes> {
    const result = super.tryCall(
      "execOnSubmodule",
      "execOnSubmodule(bytes20,bytes):(bytes)",
      [
        ethereum.Value.fromFixedBytes(subKeycode_),
        ethereum.Value.fromBytes(callData_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getAssetData(asset_: Address): Price_v2__getAssetDataResultValue0Struct {
    const result = super.call(
      "getAssetData",
      "getAssetData(address):((bool,bool,bool,uint32,uint16,uint16,uint48,uint256,uint256[],bytes,bytes))",
      [ethereum.Value.fromAddress(asset_)],
    );

    return changetype<Price_v2__getAssetDataResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getAssetData(
    asset_: Address,
  ): ethereum.CallResult<Price_v2__getAssetDataResultValue0Struct> {
    const result = super.tryCall(
      "getAssetData",
      "getAssetData(address):((bool,bool,bool,uint32,uint16,uint16,uint48,uint256,uint256[],bytes,bytes))",
      [ethereum.Value.fromAddress(asset_)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Price_v2__getAssetDataResultValue0Struct>(value[0].toTuple()),
    );
  }

  getAssets(): Array<Address> {
    const result = super.call("getAssets", "getAssets():(address[])", []);

    return result[0].toAddressArray();
  }

  try_getAssets(): ethereum.CallResult<Array<Address>> {
    const result = super.tryCall("getAssets", "getAssets():(address[])", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getPrice(asset_: Address, variant_: i32): Price_v2__getPriceResult {
    const result = super.call(
      "getPrice",
      "getPrice(address,uint8):(uint256,uint48)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(variant_)),
      ],
    );

    return new Price_v2__getPriceResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_getPrice(
    asset_: Address,
    variant_: i32,
  ): ethereum.CallResult<Price_v2__getPriceResult> {
    const result = super.tryCall(
      "getPrice",
      "getPrice(address,uint8):(uint256,uint48)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(variant_)),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Price_v2__getPriceResult(value[0].toBigInt(), value[1].toBigInt()),
    );
  }

  getPrice1(asset_: Address): BigInt {
    const result = super.call("getPrice", "getPrice(address):(uint256)", [
      ethereum.Value.fromAddress(asset_),
    ]);

    return result[0].toBigInt();
  }

  try_getPrice1(asset_: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall("getPrice", "getPrice(address):(uint256)", [
      ethereum.Value.fromAddress(asset_),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPrice2(asset_: Address, maxAge_: BigInt): BigInt {
    const result = super.call("getPrice", "getPrice(address,uint48):(uint256)", [
      ethereum.Value.fromAddress(asset_),
      ethereum.Value.fromUnsignedBigInt(maxAge_),
    ]);

    return result[0].toBigInt();
  }

  try_getPrice2(asset_: Address, maxAge_: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getPrice",
      "getPrice(address,uint48):(uint256)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromUnsignedBigInt(maxAge_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceIn(asset_: Address, base_: Address): BigInt {
    const result = super.call(
      "getPriceIn",
      "getPriceIn(address,address):(uint256)",
      [ethereum.Value.fromAddress(asset_), ethereum.Value.fromAddress(base_)],
    );

    return result[0].toBigInt();
  }

  try_getPriceIn(asset_: Address, base_: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getPriceIn",
      "getPriceIn(address,address):(uint256)",
      [ethereum.Value.fromAddress(asset_), ethereum.Value.fromAddress(base_)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceIn1(asset_: Address, base_: Address, maxAge_: BigInt): BigInt {
    const result = super.call(
      "getPriceIn",
      "getPriceIn(address,address,uint48):(uint256)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromAddress(base_),
        ethereum.Value.fromUnsignedBigInt(maxAge_),
      ],
    );

    return result[0].toBigInt();
  }

  try_getPriceIn1(
    asset_: Address,
    base_: Address,
    maxAge_: BigInt,
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getPriceIn",
      "getPriceIn(address,address,uint48):(uint256)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromAddress(base_),
        ethereum.Value.fromUnsignedBigInt(maxAge_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceIn2(
    asset_: Address,
    base_: Address,
    variant_: i32,
  ): Price_v2__getPriceIn2Result {
    const result = super.call(
      "getPriceIn",
      "getPriceIn(address,address,uint8):(uint256,uint48)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromAddress(base_),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(variant_)),
      ],
    );

    return new Price_v2__getPriceIn2Result(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_getPriceIn2(
    asset_: Address,
    base_: Address,
    variant_: i32,
  ): ethereum.CallResult<Price_v2__getPriceIn2Result> {
    const result = super.tryCall(
      "getPriceIn",
      "getPriceIn(address,address,uint8):(uint256,uint48)",
      [
        ethereum.Value.fromAddress(asset_),
        ethereum.Value.fromAddress(base_),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(variant_)),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Price_v2__getPriceIn2Result(value[0].toBigInt(), value[1].toBigInt()),
    );
  }

  getSubmoduleForKeycode(param0: Bytes): Address {
    const result = super.call(
      "getSubmoduleForKeycode",
      "getSubmoduleForKeycode(bytes20):(address)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return result[0].toAddress();
  }

  try_getSubmoduleForKeycode(param0: Bytes): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "getSubmoduleForKeycode",
      "getSubmoduleForKeycode(bytes20):(address)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getSubmodules(): Array<Bytes> {
    const result = super.call("getSubmodules", "getSubmodules():(bytes20[])", []);

    return result[0].toBytesArray();
  }

  try_getSubmodules(): ethereum.CallResult<Array<Bytes>> {
    const result = super.tryCall(
      "getSubmodules",
      "getSubmodules():(bytes20[])",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  isAssetApproved(asset_: Address): boolean {
    const result = super.call(
      "isAssetApproved",
      "isAssetApproved(address):(bool)",
      [ethereum.Value.fromAddress(asset_)],
    );

    return result[0].toBoolean();
  }

  try_isAssetApproved(asset_: Address): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "isAssetApproved",
      "isAssetApproved(address):(bool)",
      [ethereum.Value.fromAddress(asset_)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  kernel(): Address {
    const result = super.call("kernel", "kernel():(address)", []);

    return result[0].toAddress();
  }

  try_kernel(): ethereum.CallResult<Address> {
    const result = super.tryCall("kernel", "kernel():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  observationFrequency(): BigInt {
    const result = super.call(
      "observationFrequency",
      "observationFrequency():(uint32)",
      [],
    );

    return result[0].toBigInt();
  }

  try_observationFrequency(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "observationFrequency",
      "observationFrequency():(uint32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  submodules(param0: BigInt): Bytes {
    const result = super.call("submodules", "submodules(uint256):(bytes20)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);

    return result[0].toBytes();
  }

  try_submodules(param0: BigInt): ethereum.CallResult<Bytes> {
    const result = super.tryCall("submodules", "submodules(uint256):(bytes20)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }
}

export class INITCall extends ethereum.Call {
  get inputs(): INITCall__Inputs {
    return new INITCall__Inputs(this);
  }

  get outputs(): INITCall__Outputs {
    return new INITCall__Outputs(this);
  }
}

export class INITCall__Inputs {
  _call: INITCall;

  constructor(call: INITCall) {
    this._call = call;
  }
}

export class INITCall__Outputs {
  _call: INITCall;

  constructor(call: INITCall) {
    this._call = call;
  }
}

export class AddAssetCall extends ethereum.Call {
  get inputs(): AddAssetCall__Inputs {
    return new AddAssetCall__Inputs(this);
  }

  get outputs(): AddAssetCall__Outputs {
    return new AddAssetCall__Outputs(this);
  }
}

export class AddAssetCall__Inputs {
  _call: AddAssetCall;

  constructor(call: AddAssetCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get storeMovingAverage_(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get useMovingAverage_(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get movingAverageDuration_(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get lastObservationTime_(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get observations_(): Array<BigInt> {
    return this._call.inputValues[5].value.toBigIntArray();
  }

  get strategy_(): AddAssetCallStrategy_Struct {
    return changetype<AddAssetCallStrategy_Struct>(
      this._call.inputValues[6].value.toTuple(),
    );
  }

  get feeds_(): Array<AddAssetCallFeeds_Struct> {
    return this._call.inputValues[7].value.toTupleArray<AddAssetCallFeeds_Struct>();
  }
}

export class AddAssetCall__Outputs {
  _call: AddAssetCall;

  constructor(call: AddAssetCall) {
    this._call = call;
  }
}

export class AddAssetCallStrategy_Struct extends ethereum.Tuple {
  get target(): Bytes {
    return this[0].toBytes();
  }

  get selector(): Bytes {
    return this[1].toBytes();
  }

  get params(): Bytes {
    return this[2].toBytes();
  }
}

export class AddAssetCallFeeds_Struct extends ethereum.Tuple {
  get target(): Bytes {
    return this[0].toBytes();
  }

  get selector(): Bytes {
    return this[1].toBytes();
  }

  get params(): Bytes {
    return this[2].toBytes();
  }
}

export class ChangeKernelCall extends ethereum.Call {
  get inputs(): ChangeKernelCall__Inputs {
    return new ChangeKernelCall__Inputs(this);
  }

  get outputs(): ChangeKernelCall__Outputs {
    return new ChangeKernelCall__Outputs(this);
  }
}

export class ChangeKernelCall__Inputs {
  _call: ChangeKernelCall;

  constructor(call: ChangeKernelCall) {
    this._call = call;
  }

  get newKernel_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ChangeKernelCall__Outputs {
  _call: ChangeKernelCall;

  constructor(call: ChangeKernelCall) {
    this._call = call;
  }
}

export class ExecOnSubmoduleCall extends ethereum.Call {
  get inputs(): ExecOnSubmoduleCall__Inputs {
    return new ExecOnSubmoduleCall__Inputs(this);
  }

  get outputs(): ExecOnSubmoduleCall__Outputs {
    return new ExecOnSubmoduleCall__Outputs(this);
  }
}

export class ExecOnSubmoduleCall__Inputs {
  _call: ExecOnSubmoduleCall;

  constructor(call: ExecOnSubmoduleCall) {
    this._call = call;
  }

  get subKeycode_(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get callData_(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ExecOnSubmoduleCall__Outputs {
  _call: ExecOnSubmoduleCall;

  constructor(call: ExecOnSubmoduleCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class InstallSubmoduleCall extends ethereum.Call {
  get inputs(): InstallSubmoduleCall__Inputs {
    return new InstallSubmoduleCall__Inputs(this);
  }

  get outputs(): InstallSubmoduleCall__Outputs {
    return new InstallSubmoduleCall__Outputs(this);
  }
}

export class InstallSubmoduleCall__Inputs {
  _call: InstallSubmoduleCall;

  constructor(call: InstallSubmoduleCall) {
    this._call = call;
  }

  get newSubmodule_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InstallSubmoduleCall__Outputs {
  _call: InstallSubmoduleCall;

  constructor(call: InstallSubmoduleCall) {
    this._call = call;
  }
}

export class RemoveAssetCall extends ethereum.Call {
  get inputs(): RemoveAssetCall__Inputs {
    return new RemoveAssetCall__Inputs(this);
  }

  get outputs(): RemoveAssetCall__Outputs {
    return new RemoveAssetCall__Outputs(this);
  }
}

export class RemoveAssetCall__Inputs {
  _call: RemoveAssetCall;

  constructor(call: RemoveAssetCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveAssetCall__Outputs {
  _call: RemoveAssetCall;

  constructor(call: RemoveAssetCall) {
    this._call = call;
  }
}

export class StoreObservationsCall extends ethereum.Call {
  get inputs(): StoreObservationsCall__Inputs {
    return new StoreObservationsCall__Inputs(this);
  }

  get outputs(): StoreObservationsCall__Outputs {
    return new StoreObservationsCall__Outputs(this);
  }
}

export class StoreObservationsCall__Inputs {
  _call: StoreObservationsCall;

  constructor(call: StoreObservationsCall) {
    this._call = call;
  }
}

export class StoreObservationsCall__Outputs {
  _call: StoreObservationsCall;

  constructor(call: StoreObservationsCall) {
    this._call = call;
  }
}

export class StorePriceCall extends ethereum.Call {
  get inputs(): StorePriceCall__Inputs {
    return new StorePriceCall__Inputs(this);
  }

  get outputs(): StorePriceCall__Outputs {
    return new StorePriceCall__Outputs(this);
  }
}

export class StorePriceCall__Inputs {
  _call: StorePriceCall;

  constructor(call: StorePriceCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class StorePriceCall__Outputs {
  _call: StorePriceCall;

  constructor(call: StorePriceCall) {
    this._call = call;
  }
}

export class UpdateAssetMovingAverageCall extends ethereum.Call {
  get inputs(): UpdateAssetMovingAverageCall__Inputs {
    return new UpdateAssetMovingAverageCall__Inputs(this);
  }

  get outputs(): UpdateAssetMovingAverageCall__Outputs {
    return new UpdateAssetMovingAverageCall__Outputs(this);
  }
}

export class UpdateAssetMovingAverageCall__Inputs {
  _call: UpdateAssetMovingAverageCall;

  constructor(call: UpdateAssetMovingAverageCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get storeMovingAverage_(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get movingAverageDuration_(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get lastObservationTime_(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get observations_(): Array<BigInt> {
    return this._call.inputValues[4].value.toBigIntArray();
  }
}

export class UpdateAssetMovingAverageCall__Outputs {
  _call: UpdateAssetMovingAverageCall;

  constructor(call: UpdateAssetMovingAverageCall) {
    this._call = call;
  }
}

export class UpdateAssetPriceFeedsCall extends ethereum.Call {
  get inputs(): UpdateAssetPriceFeedsCall__Inputs {
    return new UpdateAssetPriceFeedsCall__Inputs(this);
  }

  get outputs(): UpdateAssetPriceFeedsCall__Outputs {
    return new UpdateAssetPriceFeedsCall__Outputs(this);
  }
}

export class UpdateAssetPriceFeedsCall__Inputs {
  _call: UpdateAssetPriceFeedsCall;

  constructor(call: UpdateAssetPriceFeedsCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get feeds_(): Array<UpdateAssetPriceFeedsCallFeeds_Struct> {
    return this._call.inputValues[1].value.toTupleArray<UpdateAssetPriceFeedsCallFeeds_Struct>();
  }
}

export class UpdateAssetPriceFeedsCall__Outputs {
  _call: UpdateAssetPriceFeedsCall;

  constructor(call: UpdateAssetPriceFeedsCall) {
    this._call = call;
  }
}

export class UpdateAssetPriceFeedsCallFeeds_Struct extends ethereum.Tuple {
  get target(): Bytes {
    return this[0].toBytes();
  }

  get selector(): Bytes {
    return this[1].toBytes();
  }

  get params(): Bytes {
    return this[2].toBytes();
  }
}

export class UpdateAssetPriceStrategyCall extends ethereum.Call {
  get inputs(): UpdateAssetPriceStrategyCall__Inputs {
    return new UpdateAssetPriceStrategyCall__Inputs(this);
  }

  get outputs(): UpdateAssetPriceStrategyCall__Outputs {
    return new UpdateAssetPriceStrategyCall__Outputs(this);
  }
}

export class UpdateAssetPriceStrategyCall__Inputs {
  _call: UpdateAssetPriceStrategyCall;

  constructor(call: UpdateAssetPriceStrategyCall) {
    this._call = call;
  }

  get asset_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get strategy_(): UpdateAssetPriceStrategyCallStrategy_Struct {
    return changetype<UpdateAssetPriceStrategyCallStrategy_Struct>(
      this._call.inputValues[1].value.toTuple(),
    );
  }

  get useMovingAverage_(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class UpdateAssetPriceStrategyCall__Outputs {
  _call: UpdateAssetPriceStrategyCall;

  constructor(call: UpdateAssetPriceStrategyCall) {
    this._call = call;
  }
}

export class UpdateAssetPriceStrategyCallStrategy_Struct extends ethereum.Tuple {
  get target(): Bytes {
    return this[0].toBytes();
  }

  get selector(): Bytes {
    return this[1].toBytes();
  }

  get params(): Bytes {
    return this[2].toBytes();
  }
}

export class UpgradeSubmoduleCall extends ethereum.Call {
  get inputs(): UpgradeSubmoduleCall__Inputs {
    return new UpgradeSubmoduleCall__Inputs(this);
  }

  get outputs(): UpgradeSubmoduleCall__Outputs {
    return new UpgradeSubmoduleCall__Outputs(this);
  }
}

export class UpgradeSubmoduleCall__Inputs {
  _call: UpgradeSubmoduleCall;

  constructor(call: UpgradeSubmoduleCall) {
    this._call = call;
  }

  get newSubmodule_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpgradeSubmoduleCall__Outputs {
  _call: UpgradeSubmoduleCall;

  constructor(call: UpgradeSubmoduleCall) {
    this._call = call;
  }
}
